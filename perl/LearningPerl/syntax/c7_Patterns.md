# 正则表达式
### 三种形式
1. 匹配: m/*regrex*/ 或者 /*regrex*/
2. 替换: s/*pattern*/*replacement*/
3. 转化: tr/*pattern*/*replacement*

### 元字符（Meta-character）
元字符 | 作用
-------- | --------
\ | 引用下一个元字符
^ | 行首
. | 任意一个字符
$ | 行尾
\| | 可选
() | 分组. 例如, /(aaa)(?:bbb)(ccc)/, $1为(aaa)匹配的到的内容，$2为(?:bbb)，依次类推
[] | 一类字符集中的一个. 例如, [0-9]表示范围，[^0-9]表示补集，除0-9外的一个

### 量词（Quantifier）
量词 | 作用
---- | ----
* | 0或任意次
+ | 1或任意次
？ | 0或一次
{n} | n次
{n, } | 至少n次
{n, m} | n到m次

### 转义字符作为通配符（Character Ranges）
转义字符 | 模式 | 作用
---- | ---- | ----
\d | [0-9] | 任何数字
\w | [a-zA-Z_0-9] | 26个字母，10个数字，下划线'_'
\s | [\t\n\r\f] | 空白字符，如tab，回车，空格
\D | [^0-9] | \d的补集
\W | [^a-zA-Z_0-9] | \w的补集
\S | [^\t\n\r\f] | \s的补集

### 模式修饰符
* 针对**m//**的modifier  

修饰符 | 作用
---- | ----
g | 全局搜索
i | 忽略大小写
m | 多行模式
s | 单行模式
x | 允许在模式中增加空白和注释，为了增加模式可读性
o | 仅赋值一次

* 针对**s///**的modifier

修饰符 | 作用
---- | ----
g | 全局搜索
i | 忽略大小写
m | 多行模式
e | 替换字符串作为表达式
s | 单行模式
x | 允许在模式中增加空白和注释，为了增加模式可读性
o | 仅赋值一次

* 针对**tr///**的modifier

修饰符 | 作用
---- | ----
c | 转化所有未指定的字符
d | 删除所有指定的字符
s | 把多个相同的字符转化成一个特定的字符

### 扩展模式（Extend Pattern）
扩展模式 | 作用
---- | ----
(?#text) | 注释，在使用/x的情况下
(?:pattern) | 设置pattern为非捕获组，不分配组编号
(?\|pattern) | 分支重置

### 模式运算
* =~ 或 !~

  将产生两种结果，
		
		$string =~ m/a/;		# 匹配成功返回true，失败反悔false
		$string =~ s/a/hello/; 	# 返回匹配之后的string

* split(/*regrex*/, "*string*")  

  把string使用regrex进行分割，并把结果放入队列，若string未空，默认使用$_  
		
		@personal = split(/:/, $info);

* join(/*delimiter*/, *@list*)

  与split作用想法，在list的各个元素间加入分隔符，反悔string
  
		$string = join(' ', @list);


### 一些常识性的知识
1. Pattern默认与$_进行匹配，例如

		if (/abc/) {
			print "$_\n";
		}

2. 匹配方式

	* 贪婪方式：匹配成功的前提下，尽可能**多**的匹配
	* 非贪婪方式：匹配成功的前提下，尽可能**少**的匹配
	* 占有式

3. 仅对标量变量进行匹配，例如

		$scalar =~ m/a/;	# 正确
		@list =~ m/a/;		# 错误，或者将把@list当做标量变量进行匹配
	
4. 正则表达式对一个给定模式的最早的匹配结果，例如

		$string = "string1, string2";
		$string =~ s/string/ /;		#$string将是 “  string2”，因此需要/g修饰符
 
5. 正则表达式的核心在于使用**通配符**和**量词**